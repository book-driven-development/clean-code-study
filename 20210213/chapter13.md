# Chapter 13 - 동시성

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [Chapter 13 - 동시성](#chapter-13-동시성)
  - [Intro](#intro)
  - [동시성이 필요한 이유](#동시성이-필요한-이유)
    - [미신과 오해](#미신과-오해)
  - [난관](#난관)
  - [동시성 방어 원칙](#동시성-방어-원칙)
    - [단일책임 원칙Single Responsibility Principle, SRP](#단일책임-원칙supsingle-responsibility-principle-srpsup)
    - [따름 정리corollary: 자료 범위를 제한하라](#따름-정리supcorollarysup-자료-범위를-제한하라)
    - [따름정리: 자료 사본을 사용하라](#따름정리-자료-사본을-사용하라)
    - [따름정리: 스레드는 가능한 독립적으로 구현하라](#따름정리-스레드는-가능한-독립적으로-구현하라)
  - [라이브러리를 이해하라](#라이브러리를-이해하라)
    - [스레드 환경에 안전한 컬렉션](#스레드-환경에-안전한-컬렉션)
  - [실행 모델을 이해하라](#실행-모델을-이해하라)
    - [생산자-소비자Producer-Consumer](#생산자-소비자supproducer-consumersup)
    - [읽기-쓰기Readers-Writers](#읽기-쓰기supreaders-writerssup)
    - [식사하는 철학자들Dining Philosophers](#식사하는-철학자들supdining-philosopherssup)
  - [동기화 하는 메서드 사이에 존재하는 의존성을 이해하라](#동기화-하는-메서드-사이에-존재하는-의존성을-이해하라)
  - [동기화 하는 부분을 작게 만들어라](#동기화-하는-부분을-작게-만들어라)
  - [올바른 종료코드는 구현하기 어렵다](#올바른-종료코드는-구현하기-어렵다)
  - [스레드 코드 테스트하기](#스레드-코드-테스트하기)
    - [말이 안되는 실패는 잠정적인 스레드 문제로 취급하라](#말이-안되는-실패는-잠정적인-스레드-문제로-취급하라)
    - [다중 스레드를 고려하지 않은 순차코드부터 제대로 돌게 만들자](#다중-스레드를-고려하지-않은-순차코드부터-제대로-돌게-만들자)
    - [다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라](#다중-스레드를-쓰는-코드-부분을-다양한-환경에-쉽게-끼워-넣을-수-있게-스레드-코드를-구현하라)
    - [다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라](#다중-스레드를-쓰는-코드-부분을-상황에-맞게-조율할-수-있게-작성하라)
    - [프로세서 수보다 많은 스레드를 돌려보라](#프로세서-수보다-많은-스레드를-돌려보라)
    - [다른 플랫폼에서 돌려보라](#다른-플랫폼에서-돌려보라)
    - [코드에 보조 코드instrument를 넣어 돌려라. 강제로 실패를 일으키게 해보라](#코드에-보조-코드supinstrumentsup를-넣어-돌려라-강제로-실패를-일으키게-해보라)
      - [직접 구현하기](#직접-구현하기)
      - [자동화](#자동화)

<!-- /code_chunk_output -->

## Intro
Thread를 하나만 실행하는 코드는 짜기가 쉽다. 겉으로 보기에는 멀쩡하지만 깊숙한 곳에 문제가 있는 다중 Thread 코드도 짜기 쉽다. 시스템이 커지고 부하가 커지면 문제는 발생한다. 이를 해결하기 위해 지키는 규칙에 대해 소개한다.

## 동시성이 필요한 이유
동시성은 결합<sup>coupling</sup>을 없애는 전략이다. 즉, **무엇**<sup>what</sup>과 **언제**<sup>when</sup>를 분리하는 전략이다.
**무엇**과 **언제**를 분리하면 효율은 극적으로 나아진다. 구조적인 관점에서 프로그램은 거대한 루프하나가 아니라 작은 협력프로그램 여러개가 돌아가는것으로 보인다.
따라서 시스템을 이해하기 쉽고 문제를 분리하기도 쉽다.


### 미신과 오해
반드시 동시성이 필요한 상황이 존재한다. 하지만 동시성은 어렵다

**동시성과 관련한 미신과 오해**
- 동시성은 항상 성능을 높여준다 (X)
    - 동시성은 때로 성능을 높여준다
- 동시성을 구현해도 설계는 변하지 않는다 (X)
    - 단일스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다
- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다 (X)
    - 실제로 컨테이너가 어떻게 동작하는지, 어떻게 동시수정, 데드락등과 같은 문제를 피할 수 있는지 알아야한다.

**동시성과 관련한 타당한 생각 몇가지**
- 동시성은 다소 부하를 유발한다
    - 성능적인 측면에서 부하가 걸리며, 코드도 더 짜야한다
- 동시성은 복잡하다
- 일반적으로 동시성 버그는 재현하기 어렵다
- 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다


## 난관
동시성을 구현하기 어려운 이유
```
 public class X {
    private int lastIdUsed;

    public int getNextId() {
        return ++lastIdUsed;
    }
}
```
인스턴스 X를 생성하고, `lastIdUsed` 필드를 42로 설정한 다음, 두 스레드가 해당 인스턴스를 공유한다.
그 두 스레드가 `getNextId();`를 호출한다.

결과는 셋 중 하나다
- 한 스레드는 43을 받는다. 다른 스레드는 44를 받는다. `lastIdUsed`는 44가 된다.
- 한 스레드는 44를 받는다. 다른 스레드는 43을 받는다. `lastIdUsed`는 44가 된다.
- 한 스레드는 43을 받는다. 다른 스레드는 43을 받는다. `lastIdUsed`는 43이 된다.

위의 getNextId() 메서드는 8개의 자바 byte-code로 변환되며, 이를 두 스레드에서 실행하게 되면 총 12,870개의 코드 조합을 낼 수 있다. 그 중 얼마 안 되는 몇몇 조합이 위의 3가지 결과 중 마지막 결과를 낳게 된다.


## 동시성 방어 원칙
동시성 코드가 일으키는 문제로부터 시스템을 방어하는 원칙과 기술

### 단일책임 원칙<sup>Single Responsibility Principle, SRP</sup>
SRP는 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙이다.
동시성은 복잡성 하나만으로도 따로 분리할 이유가 충분하다.
즉, 동시성관련 코드는 다른 코드와 분리해야 한다는 것이다.

동시성을 구현할 때는 다음 몇가지를 고려한다.
- 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.
- 동시성 코드에는 독자적인 난관이 있다. 다른코드에서 겪는 난관과 다르며 훨씬 어렵다.
- 잘못 구현한 동시성 코드는 별의별 방식으로 실패한다. 주변에 있는 다른 코드가 발목을 잡지 않더라도 동시성 하나만으로도 충분히 어렵다.

**권장사항**: 동시성 코드는 다른 코드와 분리하라

### 따름 정리<sup>corollary</sup>: 자료 범위를 제한하라
객체하나를 공유한 후 두 스레드가 동일필드 수정을 하게되면 서로 간섭하므로 예상치 못한 결과가 나온다.
이 문제를 해결하는 방안으로 공유 객체를 사용하는 내 **임계영역**<sup>critical section</sup>을 **synchronized** 키워드로 보호하라고 권장한다.
이런 임계영역의 수를 줄이는 기술이 중요하다. 공유자료를 수정하는 위치가 많을수록 아래 가능성이 커진다.
- 보호할 임계영역을 빼먹는다. 
- 모든 임계영역을 올바르게 보호하였는지 확인하느라 똑같은 노력과 수고를 반복한다.
- 그렇지 않아도 찾아내기 어려운 버그가 더욱 찾기 어려워진다.

**권장사항**: 자료를 캡슐화 하라. 공유자료를 최대한 줄여라

### 따름정리: 자료 사본을 사용하라
어떤 경우에는 객체를 복사해 일기 전용으로 사용하는 방법이 가능하다.
사본으로 동기화를 피할 수 있다면 내부 잠금(synchronized)을 없애 절약한 수행시간이 사본 생성과 가빚 ㅣ컬렉션에 드는 부하를 상쇄할 가능성이 크다.

### 따름정리: 스레드는 가능한 독립적으로 구현하라
자신만의 세상에 존재하는 스레드를 구현한다. 즉, 다른 스레드와 자료를 공유하지 않는다.
각 스레드는 세상에 자신만 있는듯이 돌아갈 수 있다. 다른스레드와 동기화할 필요가 없어진다.

**권장사항**: 독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라


## 라이브러리를 이해하라
- 자바에서 제공하는 thread-safe 컬랙션을 사용하라. ex) ConCurrentHashMap, Vector
- 연관이 없는 태스크들을 수행시 executor 프레임워크를 사용하라.
- 가능하면 nonblocking 방법을 사용하라.
- 몇몇 라이브러리 클래스들은 thread-safe하지 않다.

### 스레드 환경에 안전한 컬렉션
`java.util.concurrent` 패키지는 멀티 스레드 환경에서 사용할 수 있는 컬랙션들을 제공한다. 
ConcurrentHashMap의 경우에는 일반 HashMap보다 대부분의 상황에서 더 좋은 퍼포먼스를 제공한다.
만약 배포 환경이 자바 5버전 이상이라면 이 패키지를 활용하자. 아래와 같은 고급 concurrency 디자인 구현을 위한 컴포넌트들도 숙지하자.

|Name|Description|
|----|------|
|ReentrantLock|한 메서드에서 잠그고 다른 메서드에서 해제될 수 있는 lock이다.|
|Semaphore|전통적인 세마포어(갯수를 셀 수 있는 lock)의 구현체이다.|
|CountDownLatch|기다리는 모든 스레드들을 해제하기 전 특정 횟수의 이벤트가 발생하는 것을 기다리게 할 수 있는 lock이다. 모든 스레드가 거의 동시에 시작될 수 있게 도와줄 수 있다.|


**권장사항**: 언어가 제공하는 클래스를 검토하라. 자바에서는 `java.util.concurrent`, `concurrent.atomic`,`java.util.concurrent.locks`


## 실행 모델을 이해하라
다중 스레드 애플리케이션을 분류하는 방식은 여러가지다.
|Name|Description|
|---|---|
|한정된 자원(Bound Resource)|다중 스레드 환경에서 사용하는 자원으로 크기나 숫자가 제한적이다. 데이터베이스 연결, 길이가 일정한 읽기/쓰기 버퍼 등이 예다.|
|상호 배제(Mutual Exclusion)|한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킨다.|
|기아(Starvation)|한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다.|
|데드락(Deadlock)|여러 스레드가 서로가 끝나기를 기다린다. 모든 스레드가 각기 필요한 자원을 다른 스레드가 점유하는 바람에 어느 쪽도 더 이상 진행하지 못한다.|
|라이브락(Livelock)|락을 거든 단계에서 각 스레드가 서로를 방해한다.|

### 생산자-소비자<sup>Producer-Consumer</sup>
하나 이상 생산자 스레드가 정보를 생성해 버퍼<sup>buffer</sup>나 대기열<sup>queue</sup>에 넣는다
하나 이상 소비자가 스레드가 대기열에서 정보를 가져와 사용한다.

생산자 스레드
- 대기열에 빈 공간이 있어야 정보를 채운다
- 빈 공간이 생길 때까지 기다린다
소비자 스레드
- 대기열에 정보가 있어야 가져온다
- 정보가 채워질 때까지 기다린다

### 읽기-쓰기<sup>Readers-Writers</sup>
일반적으로 독자를 위한 정보로 사용되며, 가끔 저자에 의해 업데이트되는 공유 자원의 경우 처리량이 문제가 된다. 처리량을 강조해 독자가 상대적인 우선권을 가지게 되면 저자는 기아 상태에 빠지며 공유 자원은 정체된 정보로 가득차게 된다. 반대로 저자가 우선권을 가지면 처리량이 줄어들게 된다. 저자-독자 문제는 이 둘 사이의 균형을 맞추며 동시성 업데이트를 방지하는 것을 주안점으로 둔다

### 식사하는 철학자들<sup>Dining Philosophers</sup>
원탁을 둘러싼 여러 명의 철학자들이 있다. 각 철학자의 왼쪽에 포크가 놓여 있으며 테이블의 중앙에 큰 스파게티 한 그릇이 놓여 있다. 그들은 배가 고파지기 전까지 각자 생각을 하며 시간을 보낸다. 배가 고파지면 그들은 자신의 양쪽에 놓여 있는 포크 2개를 잡고 스파게티를 먹는다. 철학자는 포크 2개가 있어야만 스파게티를 먹을 수 있다. 그렇지 않다면 옆 사람이 포크를 다 사용하기 전까지 기다려야 한다. 스파게티를 먹은 철학자는 다시 배가 고파질 때까지 포크를 놓고 있게 된다. 위 상황에서 철학자를 스레드로, 포크를 공유 자원으로 바꾸게 되면 이는 자원을 놓고 경쟁하는 프로세스와 비슷한 상황이 된다. 잘 설계되지 않은 시스템은 deadlock, livelock, 처리량 문제, 효율성 저하 문제에 맞닥뜨리기 쉽다. 당신이 맞닥뜨릴 대부분의 동시성관련 문제들은 이 세 가지 문제의 변형일 가능성이 높다. 이 알고리즘들을 공부하고 스스로 해법을 작성함으로써 이와 같은 문제들을 직면하더라도 의연하게 대처할 수 있도록 하자.

**권장사항**: 기본 알고리즘과 각 해법을 잘 이해하라

## 동기화 하는 메서드 사이에 존재하는 의존성을 이해하라
동기화하는 메서드 사ㅏ이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생긴다.
자바 언어는 개별 메서드를 보호하는 `synchronized` 라는 개념을 지원한다.
하지만 공유 클래스 하나에 동기화도니 메서드가 여럿이라면 구현이 올바른지 다시 한 번 확인하기 바란다.

**권장사항**: 공유 객체 하나에는 메서드 하나만 사용하라.

공유 객체 하나에 여러 메서드가 필요한 상황도 생긴다.
그 경우에는 아래와 같은 방법을 고려한다.
- 클라이언트에서 잠금: 클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠근다. 마지막 메서드를 호출할 때까지 잠금을 유지한다.
- 서버에서 잠금: 서버에다 "서버를 잠그고 모든 메서드를 호출한 후 잠금을 배제하는" 메서드를 구현한다. 클라이언트가 이 메서드를 호출한다
- 연결서버: 잠금을 수행하는 중간 단계를 생성한다. '서버에서 잠금'방식과 유사하지만 원래 서버는 변경하지 않는다.


## 동기화 하는 부분을 작게 만들어라
자바에서 `synchronized`키워드를 사용하면 락을 설정한다.
같은 락으로 감싼 코드 영역은 한 번에 한 스레드만 실행이 가능하다.
락은 스레드를 지연시키고 부하를 가중시킨다. 반면 임계영역<sup>critical section</sup>은 반드시 보호해야한다
따라서 코드를 짤 때는 임계영역 수를 최대한 줄여야한다

**권장사항**: 동기화 하는 부분을 최대한 작게 만들어라


## 올바른 종료코드는 구현하기 어렵다
'영구적으로 돌아가는 시스템을 구현하는 방법'과 잠시 돌다 '깔끔하게 종료되는 시스템을 구현하는 방법'은 다르다.
'깔끔하게 종료되는 시스템을 구현하는 방법'은 구현하기 어렵다. 가장 흔히 발생하는 문제가 데드락이다
즉, 스레드가 절대 오지않을 시그널을 기다린다.

**권장사항**: 종료코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하라. 생각보다 어려우므로 이미 나온 알고리즘을 검토하라


## 스레드 코드 테스트하기
코드가 올바르다고 증명하기는 현실적으로 불가능하다.
그럼에도 충분한 테스트는 위험을 낮춘다.
하지만 스레드가 2개일때는 테스트를 하기 복잡해진다.

**권장사항**: 문제를 노출하는 테스트 케이스를 작성하라. 프로그램 설정과 시스템설정 부하를 자주 바꿔가며 돌려라.
테스트가 실패하면 원인을 추적하라. 다시 돌렸더니 통과하더라는 이유로 그냥 넘어가면 안된다.

- 말도안되는 실패는 잠정적인 스레드 문제로 취급하라
- 다중 스레드를 고려하지 않은 순차 코드로부터 제대로 돌게 만들자
- 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 스레드 코드를 구현하라
- 다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정할 수 있게 작성하라
- 프로세서 수보다 많은 스레드를 돌려보라
- 다른 플랫폼에서 돌려보라
- 코드에 보조코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라

### 말이 안되는 실패는 잠정적인 스레드 문제로 취급하라
**권장사항**: 시스템 실패를 '일회성'이라 치부하지 마라

### 다중 스레드를 고려하지 않은 순차코드부터 제대로 돌게 만들자
**권장사항**: 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 
동시에 디버깅하지마라. 먼저 스레드 환경 밖에서 코드를 올바로 돌려라

### 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라
- 한 스레드로 실행하거나, 여러 스레드로 실행하거나, 실행 중 스레드 수를 바꿔본다
- 스레드 코드를 실제 환경이나 테스트 환경에서 돌려본다
- 테스트 코드를 빨리, 천천히, 다양한 속도로 돌려본다
- 반복 테스트가 가능하도록 테스트 케이스를 작성한다

**권장사항**: 다양한 설정에서 실행할 목적으로 다른 환경에 수비게 끼워 넣을 수 있게 코드를 구현하라

### 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
스레드 관련 코드의 적절한 균형을 맞추는 작업은 보통 시행착오를 필요로 한다. 여러 환경에서 시스템의 퍼포먼스를 테스트할 수 있는 방법을 개발 초기에 강구하라. 실행할 스레드 갯수를 쉽게 변경할 수 있게 작성하라. 이를 시스템이 동작하는 도중에 변경할 수 있게 하는 것을 고려해 보라. 처리량과 시스템 활용도를 기준으로 스스로를 조정할 수 있게 하는 것을 고려해 보라.

### 프로세서 수보다 많은 스레드를 돌려보라
시스템이 작업을 전환할 때에도 문제는 발생한다. 작업 전환을 빈번히 발생하게 하기 위해 프로세서 수보다 많은 스레드를 실행해 보라. 
작업 전환이 잦을수록 빠뜨린 critical section이나 dead lock을 찾을 확률이 높아지게 된다.

### 다른 플랫폼에서 돌려보라
**권장사항**: 처음부터 그리고 자주 모든 목표 플랫폼에서 코드를 돌려라

### 코드에 보조 코드<sup>instrument</sup>를 넣어 돌려라. 강제로 실패를 일으키게 해보라
스레드 관련 문제는 수많은 실행 경로중 얼마 안되는 확률로 발생하기 때문에 드물게 발생하며 재현하기 어렵다. 이 실행 경로를 조작해 스레드 문제가 발생할 확률을 높이는 code instrumentation에는 두 가지 방법이 있다.

- 직접 구현하기
- 자동화

#### 직접 구현하기
이는 `wait()`, `sleep()`, `yield()`, `priority()` 등의 메서드를 사용해 실행 경로를 변경함으로써 코드의 문제를 발견하는 방법이다.
```
public synchronized String nextUrlOrNull() {
    if(hasNext()) {
        String url = urlGenerator.next();
        Thread.yield();
        // inserted for testing.
        updateHasNext();
        return url;
    }
    return null;
}
```
yield() 메서드를 호출함으로써 코드의 실행 경로를 변경할 수 있다. 만약 위 코드에서 문제가 발생한다면 이는 yield()를 추가해 생긴 문제가 아니라 이미 존재하던 문제를 명백히 만든것 뿐이다. 하지만 이 방법에는 몇 가지 문제가 있다.

- 테스트할 부분을 직접 찾아야 한다.
- 어디에 어느 메서드를 호출해야 할지 알기 어렵다.
- 이와 같은 코드를 제품에 포함해 배포하는 것은 불필요하게 퍼포먼스를 저하시킬 뿐이다.
- Shotgun approach이기 때문에 반드시 문제가 발생한다는 보장을 얻을 수 없다.
우리는 실제 제품에 포함되지 않으며 여러 조합으로 실행해 에러를 찾기 쉽게 만들 방법이 필요하다. 이를 위해서는 시스템을 최대한 POJO 단위로 나눠 instrument code를 삽입할 부분을 찾기 쉽게 하고 여러 정책에 따라 sleep, yield등을 삽입할 수 있게 해야 한다.

#### 자동화
위와 다르게 Aspect-oriented Framework, CGLib, ASM등을 통해 프로그램적으로 코드를 조작할 수도 있다.
```
public class ThreadJigglePoint {
    public static void jiggle() { }
}

public synchronized String nextUrlOrNull() {
    if(hasNext()) {
        ThreadJigglePoint.jiggle();
        String url = urlGenerator.next();
        ThreadJigglePoint.jiggle();
        updateHasNext();
        ThreadJigglePoint.jiggle();
        return url;
    }
    return null;
}
```
`ThreadJigglePoint.jiggle()` 호출은 무작위로 sleep이나 yield를 호출한다
때로는 아무 동작도 하지 않는다.
혹은 ThreadJigglePoint가 두 가지 구현을 가지게 할 수도 있다. 첫 번째 구현은 배포용 코드를 위한 ‘아무 것도 안하기’를 수행하며 두 번째 구현은 ‘sleep, yield, 아무 것도 안하기’ 중의 하나를 무작위로 선택하는 것이다. 다소 간단하긴 하지만 좀 더 정교한 툴을 사용하는 대신 이 정도로 구현하는 것도 적절한 선택일 것이다.
